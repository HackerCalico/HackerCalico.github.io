<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>No_X_Memory_ShellCode_Loader | Hexo</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>No_X_Memory_ShellCode_Loader</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-08-15T04:21:28.294Z" id="date"> 2024-08-15</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-08-15T04:23:09.339Z" id="updated"> 2024-08-15</time></div></span></div></div><hr><div id="post-content"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>无需解密，无需 X 内存，直接加载运行 R 内存中的 ShellCode 密文。</p>
<p>x64 项目: <a target="_blank" rel="noopener" href="https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader">https://github.com/HackerCalico/No_X_Memory_ShellCode_Loader</a></p>
<p>规避了以下特征：</p>
<p>(1) 申请 RWX 属性的内存。</p>
<p>(2) 来回修改 W 和 X 的内存属性。</p>
<p>(3) 内存中出现 ShellCode 特征码。</p>
<p class='item-img' data-src='https://raw.githubusercontent.com/HackerCalico/No_X_Memory_ShellCode_Loader/main/run.png'><img src="https://raw.githubusercontent.com/HackerCalico/No_X_Memory_ShellCode_Loader/main/run.png" alt="1.png"></p>
<h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p><strong>加载流程：</strong></p>
<p>(1) 正常生成 ShellCode 机器码。</p>
<p>(2) ShellCode — 转换器 —&gt; 自定义汇编指令。</p>
<p>(3) 解释器 运行 自定义汇编指令。</p>
<p><strong>详细介绍：</strong></p>
<p><a target="_blank" rel="noopener" href="https://hackercalico.github.io/2024/08/13/%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%8A%A0%E8%BD%BD%20ShellCode%20%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/">https://hackercalico.github.io/2024/08/13/%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%8A%A0%E8%BD%BD%20ShellCode%20%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</a></p>
<h3 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h3><p><u>ShellCode</u>：多种 ShellCode 源码。</p>
<p><u>Converter</u>：自定义汇编指令转换器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install capstone<br></code></pre></td></tr></table></figure>

<p><u>Loader</u>：ShellCode 加载器 (自定义汇编指令解释器)。</p>
<p><u>GenerateAsmInstruction</u>：用于生成 Loader\AsmInstruction.asm 函数汇编指令。</p>
<h3 id="转换器使用与实现"><a href="#转换器使用与实现" class="headerlink" title="转换器使用与实现"></a>转换器使用与实现</h3><p>为了减轻解释器的压力，我们的自定义汇编指令一定要设计成容易解释的格式。</p>
<p><mark>下面对本项目提供的 CMD 命令执行 ShellCode 案例进行讲解：</mark></p>
<p><strong>(1) 生成原始汇编指令</strong></p>
<p>将 ShellCode 机器码 (ShellCode.txt) 转为原始汇编指令 (asm.txt)。</p>
<p>该功能简单利用 capstone 库实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; python Converter.py<br>1.反汇编<br>2.Imul转换<br>3.生成自定义汇编指令<br>选择: 1<br>ShellCode使用的汇编指令: &#123;<span class="hljs-string">&#x27;lea&#x27;</span>, <span class="hljs-string">&#x27;cdqe&#x27;</span>, ......, <span class="hljs-string">&#x27;repStosb&#x27;</span>&#125;<br>汇编指令生成完毕: asm.txt<br></code></pre></td></tr></table></figure>

<p>asm.txt：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x0</span>_mov_qword ptr [rsp + <span class="hljs-number">0x20</span>], r9<br><span class="hljs-number">0x5</span>_mov_qword ptr [rsp + <span class="hljs-number">0x18</span>], r8<br><span class="hljs-number">0xa</span>_mov_dword ptr [rsp + <span class="hljs-number">0x10</span>], edx<br>......<br></code></pre></td></tr></table></figure>

<p><strong>(2) 修改 asm.txt</strong></p>
<p>考虑到原始汇编指令可能存在一些特殊情况，需要进行修改。所以我将转换过程分为了先转为原始汇编指令，再转为自定义汇编指令两个阶段。</p>
<p>观察原始汇编指令，可以发现存在 imul 指令，并且全部为 imul a, a, b 的格式。我们直接把它们全部转为 imul a, b 的格式方便处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; python Converter.py<br>1.反汇编<br>2.Imul转换<br>3.生成自定义汇编指令<br>选择: 2<br>已将 asm.txt 中的 imul a, a, b 全部转换为 imul a, b<br></code></pre></td></tr></table></figure>

<p><strong>(3) 生成自定义汇编指令</strong></p>
<p>将 asm.txt 中的原始汇编指令转为自定义汇编指令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; python Converter.py<br>1.反汇编<br>2.Imul转换<br>3.生成自定义汇编指令<br>选择: 3<br>0_4_q_pq70+i20_q_q38_......2ed_3_q__q__!<br><br>PVOID mnemonicMap[] = &#123; Push, Pop, ......, Jle &#125;;<br></code></pre></td></tr></table></figure>

<p>0_4_q_pq70+i20_q_q38 为第一条自定义汇编指令，! 为整个自定义汇编指令的结束标志。</p>
<p>第一条的原始汇编指令：0x00 mov qword ptr [rsp + 0x20], r9</p>
<p><u>指令地址</u>：0x00 ——&gt; 0</p>
<p>在处理 Jcc 跳转指令时需要使用，去掉 0x 减短长度。</p>
<p><u>助记符</u>：mov ——&gt; 4</p>
<p>4 为 mov 在 mnemonicMap 中的下标。</p>
<p>解释器逐条指令执行，通过下标获取 mnemonicMap 中当前指令的处理函数指针，进行反射调用。避免了解释器代码中出现大量 if else 或 switch case。</p>
<p><u>操作数1</u>：qword ptr [rsp + 0x20] ——&gt; q_pq70+i20</p>
<p>q 表示 QWORD，p 表示 ptr。</p>
<p>q70 表示 vtRSP。在解释器中通过 vtRegs 数组存储虚拟寄存器的值，70 是 vtRSP 相对 vtRegs 基址的偏移，直接通过地址操作寄存器的值。避免了解释器代码中出现大量不同位数的寄存器的定义，以及繁琐操作。</p>
<p>i20 表示立即数 0x20。</p>
<p><u>操作数2</u>：r9 ——&gt; q_q38</p>
<p>q 表示 QWORD。</p>
<p>q38 表示 R9，同理偏移。</p>
<h3 id="解释器实现"><a href="#解释器实现" class="headerlink" title="解释器实现"></a>解释器实现</h3><p><strong>(1) 创建虚拟栈和虚拟寄存器</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PVOID vtStack = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10000</span>);<br><br>DWORD_PTR vtRegs[<span class="hljs-number">18</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>vtRegs[<span class="hljs-number">14</span>] = vtRegs[<span class="hljs-number">15</span>] = (DWORD_PTR)vtStack + <span class="hljs-number">0x9000</span>;<br></code></pre></td></tr></table></figure>

<p>14 和 15 分别对应 vtRSP 和 vtRBP。</p>
<p><strong>(2) 设置虚拟寄存器的初值</strong></p>
<p>因为解释器是从 ShellCode 函数的开头进行模拟的，所以在模拟开始之前，要先在虚拟空间中构建出 ShellCode 函数的参数。</p>
<p>本项目提供的 CMD 命令执行 ShellCode 函数通过以下代码调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ExecuteCmd(commandPara, commandParaLength, &amp;outputData, &amp;outputDataLength, funcAddr);<br></code></pre></td></tr></table></figure>

<p>该行代码对应的汇编指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">lea rax, [funcAddr]<br>mov qword ptr [rsp+<span class="hljs-number">20</span>h], rax<br>lea r9, [outputDataLength]<br>lea r8, [outputData]<br>mov edx, dword ptr [commandParaLength]<br>lea rcx, [commandPara]<br>call ExecuteCmd<br></code></pre></td></tr></table></figure>

<p>所以要通过以下代码在虚拟空间中构建出函数参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">vtRegs[<span class="hljs-number">0</span>] = (DWORD_PTR)pFuncAddr;<br>*(PDWORD_PTR)(vtRegs[<span class="hljs-number">14</span>] + <span class="hljs-number">0x20</span>) = vtRegs[<span class="hljs-number">0</span>];<br>vtRegs[<span class="hljs-number">7</span>] = (DWORD_PTR)pOutputDataLength;<br>vtRegs[<span class="hljs-number">6</span>] = (DWORD_PTR)pOutputData;<br>vtRegs[<span class="hljs-number">3</span>] = commandParaLength;<br>vtRegs[<span class="hljs-number">2</span>] = (DWORD_PTR)commandPara;<br>vtRegs[<span class="hljs-number">14</span>] = vtRegs[<span class="hljs-number">14</span>] - <span class="hljs-keyword">sizeof</span>(DWORD_PTR);<br></code></pre></td></tr></table></figure>

<p><strong>(3) 解析自定义汇编指令</strong></p>
<p>根据 <mark>指令地址_助记符_位数1_操作数1_位数2_操作数2</mark> 的格式将每条指令的元素解析出来。</p>
<p>通过 GetOpTypeAndAddr 函数获取每个操作数的类型和地址，每种指令的处理函数会直接通过操作数的地址对其值进行操作，非常方便。</p>
<p><u>如果操作数是立即数</u>，例如 i12 (0x12)。则直接通过 strtol 函数将 12 字符串转为数字，该数字的地址即为该操作数的地址。</p>
<p><u>如果操作数是 lea 的第二个操作数或内存空间</u>，例如 lq70+i20 ([rsp + 0x20]) 或 pq70+i20 (ptr [rsp + 0x20])。则先解析其子元素进行计算，计算结果保存到 number1。如果操作数是 lea 的第二个操作数，则 number1 的地址即为该操作数的地址。如果操作数是内存空间，则 number1 的值即为该操作数的地址。</p>
<p><u>如果操作数是寄存器</u>，例如 q70 (rsp)。70 是 vtRSP 相对 vtRegs 基址的偏移，则 vtRegs 基址 + 70 即为该操作数的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取操作数值的 类型(r寄存器/m内存空间) + 地址</span><br>DWORD_PTR <span class="hljs-title function_">GetOpTypeAndAddr</span><span class="hljs-params">(<span class="hljs-type">char</span>* op, <span class="hljs-type">char</span>* pOpType1, PDWORD_PTR pVtRegs, PDWORD_PTR opNumber)</span> &#123;<br>    ......<br>    <span class="hljs-comment">// 立即数</span><br>    <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;i&#x27;</span>) &#123;<br>        *opNumber = strtol(op + <span class="hljs-number">1</span>, &amp;endPtr, <span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">return</span> (DWORD_PTR)opNumber;<br>    &#125;<br>    <span class="hljs-comment">// lea [] / ptr []</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;l&#x27;</span> || op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;p&#x27;</span>) &#123;<br>        ......<br>        <span class="hljs-comment">// 解析算式 (未考虑“*”)</span><br>        ParseFormula(op + <span class="hljs-number">1</span>, formula, symbols);<br>        <span class="hljs-comment">// 计算 (未考虑“*”)</span><br>        DWORD_PTR number1 = <span class="hljs-number">0</span>;<br>        ......<br>        <span class="hljs-comment">// lea []</span><br>        <span class="hljs-keyword">if</span> (op[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;l&#x27;</span>) &#123;<br>            *opNumber = number1;<br>            <span class="hljs-keyword">return</span> (DWORD_PTR)opNumber;<br>        &#125;<br>        <span class="hljs-comment">// ptr []</span><br>        <span class="hljs-keyword">if</span> (pOpType1 != <span class="hljs-literal">NULL</span>) &#123;<br>            *pOpType1 = <span class="hljs-string">&#x27;m&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> number1;<br>    &#125;<br>    <span class="hljs-comment">// 寄存器</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (pOpType1 != <span class="hljs-literal">NULL</span>) &#123;<br>            *pOpType1 = <span class="hljs-string">&#x27;r&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (DWORD_PTR)pVtRegs + strtol(op + <span class="hljs-number">1</span>, &amp;endPtr, <span class="hljs-number">16</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>(4) 调用对应指令的处理函数</strong></p>
<p>通过解析得到的当前指令的下标获取当前指令的处理函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">PVOID mnemonicMap[] = &#123; Push, Pop, ......, AsmJle &#125;;<br>PVOID instructionFunc = mnemonicMap[mnemonicIndex];<br></code></pre></td></tr></table></figure>

<p><mark>下面举几种指令的处理函数的例子：</mark></p>
<p><u>Mov 指令</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 其他两个操作数的指令</span><br><span class="hljs-keyword">else</span> &#123;<br>    ((<span class="hljs-type">void</span>(*)(...))instructionFunc)(opType1, opBit1, opAddr1, opBit2, opAddr2);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Mov</span><span class="hljs-params">(<span class="hljs-type">char</span> opType1, <span class="hljs-type">char</span> opBit1, DWORD_PTR opAddr1, <span class="hljs-type">char</span> opBit2, DWORD_PTR opAddr2)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (opBit1)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>        *(PDWORD64)opAddr1 = *(PDWORD64)opAddr2;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>        <span class="hljs-keyword">if</span> (opType1 == <span class="hljs-string">&#x27;r&#x27;</span>) &#123;<br>            *(PDWORD_PTR)opAddr1 = *(PDWORD)opAddr2;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            *(PDWORD)opAddr1 = *(PDWORD)opAddr2;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>        *(PWORD)opAddr1 = *(PWORD)opAddr2;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>        *(PBYTE)opAddr1 = *(PBYTE)opAddr2;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>case ‘d’ 表示 操作数1 为 DWORD，在 操作数1 类型为 DWORD 寄存器时存在特殊情况。</p>
<p>特殊情况通过下例来解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">mov rax, <span class="hljs-number">0x1234567812345678</span><br>mov eax, <span class="hljs-number">0x11111111</span><br></code></pre></td></tr></table></figure>

<p>运行后 rax 为 0x0000000011111111。</p>
<p><u>Cmp 指令</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instructionFunc == AsmCmp || instructionFunc == AsmTest) &#123;<br>     ((<span class="hljs-type">void</span>(*)(...))instructionFunc)(opBit1, opAddr1, opAddr2, pVtRegs);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将两个操作数的值赋值到 r10 和 r11，计算完成后将标志寄存器的值赋值到 vtEFL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AsmCmp</span><span class="hljs-params">(<span class="hljs-type">char</span> opBit1, DWORD_PTR opAddr1, DWORD_PTR opAddr2, PDWORD_PTR pVtRegs)</span> &#123;<br>    __asm &#123;<br>        mov r8, qword ptr[opAddr1]<br>        mov r9, qword ptr[opAddr2]<br>        mov r10, qword ptr[r8]<br>        mov r11, qword ptr[r9]<br>    &#125;<br>    DWORD_PTR vtEFL;<br>    <span class="hljs-keyword">switch</span> (opBit1)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>        __asm &#123;<br>            cmp r10, r11<br>            pushf<br>            pop rax<br>            mov vtEFL, rax<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    ......<br>    &#125;<br>    pVtRegs[<span class="hljs-number">17</span>] = vtEFL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><u>Jcc 指令</u></p>
<p>传入具体的 Jcc 指令的处理函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Jcc(instructionFunc, opAddr1, pVtRegs);<br></code></pre></td></tr></table></figure>

<p>通过具体的 Jcc 指令的处理函数判断是否跳转。如果跳转，则将 操作数1 的值赋值给 vtRIP。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Jcc</span><span class="hljs-params">(PVOID instructionFunc, DWORD_PTR opAddr1, PDWORD_PTR pVtRegs)</span> &#123;<br>    DWORD_PTR vtEFL = pVtRegs[<span class="hljs-number">17</span>];<br>    <span class="hljs-type">int</span> isJmp = ((<span class="hljs-type">int</span>(*)(...))instructionFunc)(vtEFL);<br>    <span class="hljs-keyword">if</span> (isJmp) &#123;<br>        DWORD_PTR vtRIP = *(PDWORD_PTR)opAddr1;<br>        pVtRegs[<span class="hljs-number">16</span>] = vtRIP;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><u>Je 指令</u></p>
<p>作为具体的 Jcc 指令的处理函数，先将 vtEFL 的值赋值到标志寄存器，再判断是否跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">AsmJe</span><span class="hljs-params">(DWORD_PTR vtEFL)</span> &#123;<br>    <span class="hljs-type">int</span> isJmp = <span class="hljs-number">1</span>;<br>    __asm &#123;<br>        mov rax, vtEFL<br>        push rax<br>        popf<br>        je jmp<br>        mov isJmp, <span class="hljs-number">0x00</span><br>        jmp :<br>    &#125;<br>    <span class="hljs-keyword">return</span> isJmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><u>Call 指令</u></p>
<p>其实现是所有指令中最复杂的，因为涉及到 Windows API 的调用。</p>
<p>首先保存真实栈顶栈底，最后还原真实栈顶栈底，保证解释器能正常运行。</p>
<p>调用 Windows API 之前，要先将虚拟寄存器的值覆盖真实寄存器的值，相当于构造好 Windows API 的参数。</p>
<p>调用完 Windows API 之后，要将真实寄存器的值覆盖虚拟寄存器的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AsmCall</span><span class="hljs-params">(DWORD_PTR opAddr1, PDWORD_PTR pVtRegs)</span> &#123;<br>    <span class="hljs-comment">// 保存真实栈顶栈底</span><br>    DWORD_PTR realRSP;<br>    DWORD_PTR realRBP;<br>    __asm &#123;<br>        mov realRSP, rsp<br>        mov realRBP, rbp<br>    &#125;<br><br>    <span class="hljs-comment">// Window API 地址</span><br>    DWORD_PTR winApiAddr = *(PDWORD_PTR)opAddr1;<br><br>    <span class="hljs-comment">// 虚拟寄存器 覆盖 真实寄存器</span><br>    DWORD_PTR vtRAX = pVtRegs[<span class="hljs-number">0</span>];<br>    ......<br>    DWORD_PTR vtRBP = pVtRegs[<span class="hljs-number">15</span>];<br>    __asm &#123;<br>        mov rax, vtRAX<br>        ......<br>        mov rsp, vtRSP<br>        <span class="hljs-comment">// mov rbp, vtRBP (与 Call 冲突)</span><br>    &#125;<br><br>    <span class="hljs-comment">// 调用 Windows API</span><br>    __asm &#123;<br>        call qword ptr[winApiAddr] <span class="hljs-comment">// (call qword ptr [rbp])</span><br>    &#125;<br><br>    <span class="hljs-comment">// 保存调用 Windows API 后真实寄存器的值</span><br>    __asm &#123;<br>        push rax<br>        ......<br>        push rbp<br>    &#125;<br><br>    <span class="hljs-comment">// 真实寄存器 覆盖 虚拟寄存器</span><br>    DWORD_PTR currentRSP;<br>    __asm &#123;<br>        mov currentRSP, rsp;<br>    &#125;<br>    pVtRegs[<span class="hljs-number">0</span>] = *(PDWORD_PTR)(currentRSP + <span class="hljs-number">0x78</span>); <span class="hljs-comment">// RAX</span><br>    ......<br>    pVtRegs[<span class="hljs-number">14</span>] = *(PDWORD_PTR)(currentRSP + <span class="hljs-number">0x08</span>) + <span class="hljs-number">0x70</span>; <span class="hljs-comment">// RSP</span><br>    pVtRegs[<span class="hljs-number">15</span>] = *(PDWORD_PTR)(currentRSP + <span class="hljs-number">0x00</span>); <span class="hljs-comment">// RBP</span><br><br>    <span class="hljs-comment">// 还原真实栈顶栈底</span><br>    __asm &#123;<br>        mov rsp, realRSP<br>        mov rbp, realRBP<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-end"><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/08/13/%E6%97%A0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90%E5%8A%A0%E8%BD%BD%20ShellCode%20%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/">无可执行权限加载 ShellCode 技术原理 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">技术原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">项目文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">转换器使用与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">解释器实现</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>